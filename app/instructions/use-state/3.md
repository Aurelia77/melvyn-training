#¬†Todo list

Que seriat une formation sans une todo list ?

Dans cette exercice on va cr√©er la fameuse todo list pour en apprendre plus sur les **states immuables** et comment √ßa fonctinne.

## Part 1 : Base

La premi√®re parties va se concentrer sur la plus √©l√©mentaire des featuers : **l'ajout**.

Pour g√©rer l'ajout tu vas devoir cr√©er une m√©thode qui cr√©er une nouvelle todo et l'ajoute √† la liste.

Une todo √† ce format :

```json
{
  "id": "1222919191",
  "text": "Faire les courses",
  "completed": false
}
```

L'`id` est g√©n√©rer avec `Date.now()`.

Pour ajouter un √©l√©ment dans un state immuable tu vas devoir utiliser la m√©thode `setTodos` de `useState`.

Mais tu ne peux pas faire √ßa :

```js
todos.push(newTodo);
```

Le state ne vas pas √™tre mise √† jour. Pour informer React que le state √† chang√© tu dois cr√©er une nouvelle liste avec le nouvel √©l√©ment et utiliser `setTodos` pour mettre √† jour le state.

```js
// 1. Ajouter un nouvel √©l√©ment
const newTodos = [...todos, newTodo];
// 2. Mettre √† jour le state
setTodos(newTodos);
```

Ceci fonctionne car en faisant `[...todos]` on cr√©er une nouvelle liste avec les √©l√©ments de `todos` et en ajoutant `newTodo` on cr√©er une nouvelle liste avec un √©l√©ment en plus.

Je te laisse faire l'exerccie avec l'aide de ü¶Å !

## Part 2 : Toggle

Dans le `TodoItem` il y a un bouton pour marquer une todo comme compl√©t√©. Tu vas devoir cr√©er une m√©thode qui change le status de la todo.

Pour trouver le `todo` dans la liste, on va utiliser l'`id` de la todo.

Ta m√©thode ressemblera √† √ßa :

```js
const updateTodo = (id) => {
  // Utilise .map pour cr√©er une nouvelle liste avec le bon √©l√©ment modifi√©
};
```

## Part 3 : Remove

On va ajouter un bouton delete √† cot√© de notre todo avec ce code :

```jsx
import { Plus, Trash } from "lucide-react";

// ...

<button className="btn btn-ghost">
  <Trash size={16} />
</button>;
```

Lors du clic il va appeler la m√©thode `removeTodo` avec l'`id` de la todo.

Une fois fait tu vas devoir cr√©er la m√©thode `removeTodo` qui va supprimer la todo de la liste.

```js
const removeTodo = (id) => {
  // Utilise .filter pour cr√©er une nouvelle liste sans l'√©l√©ment √† supprimer
};
```

## Part 4 : Custom hooks

On commence √† avoir **beaucoup** de m√©thode et notre composnat `Todos` devient trop long.

La magie avec React c'est qu'on peut extraire des morceaux de logique dans des **custom hooks**.

Les **custom hooks** sont des hooks qu'on cr√©er nous m√™me. Il y a les hooks React :

- `useState`
- `useEffect`
- `useContext`
- etc...

Et nos customs hooks.

Pour cr√©er un custom hook il faut :

- Cr√©er une fonction qui commence par `use`
- Utiliser cette function **dans un composant React**

Cette function peut retourner tout ce qu'on veut :

```js
const useToggle = (initialValue = false) => {
  const [value, setValue] = useState(initialValue);

  const toggle = () => setValue(!value);

  // Ici je return `value` et `toggle` dans un objet
  return { value, toggle };
};

const Component = () => {
  // Je peux ensuite d√©structurer les valeurs
  // pour les utiliser dans mon composant
  const { value, toggle } = useToggle();

  return <button onClick={toggle}>{value ? "ON" : "OFF"}</button>;
};
```

Tu vas pouvoir cr√©er un custom hooks qui retourne :

- `addTodo(text)`
- `updateTodo(id)`
- `removeTodo(id)`
- `todos`

Tu pourras ensuite utiliser ce custom hooks dans ton composant `Todos` pour rendre le code plus lisible.

##¬†Part 5 : Update du text (Difficile)

Attention, cette partie est compliqu√© volontairement.

J'ai envie de rajouter une feature.

Quand **je clique sur le texte d'un todo**, je veux que celui-ci devienne un input pour pouvoir le modifier.

Pour √ßa, il va falloir ajouter pas mal de chose.

1. Cr√©er un state `editingId` qui va contenir l'`id` de la todo en cours d'√©dition
2. Modifier la m√©thode `updateTodo` pour qu'elle prennes en param√®tre l'`id` ET le `newTodo`

- `newTodo` repr√©sente un objet qui peux contenir la cl√© `text` ou `completed`
- Ne modifie que les √©l√©ments qui sont pass√© en param√®tre, pour √ßa tu peux utiliser cette syntaxe :

```js
{
  // on garde les anciennes valeurs
  ...todo,
  // on remplace les valeurs si elles sont pass√©es en param√®tre
  // ?? = si la valeur est null ou undefined on garde la valeur de todo
  completed: newTodo.completed ?? todo.completed,
  text: newTodo.text ?? todo.text,
}>
```

- Modifier les utilisations de `updateTodo`, notamment sur la checkbox pour qu'elle prenne en param√®tre un objet avec la cl√© `completed` qui est l'inverse de `todo.completed`

2. Modifier l'√©l√©ment todo

- il faut remplacer le `label` par un `div` pour √©viter de toggle l'√©dition √† chaque clic
- il faut utiliser un ternaire pour afficher un `input` si l'`id` est √©gal √† `editingId`
- lors du `onChange` de l'`input` il faut mettre √† jour le `newTodo` avec le nouveau texte (avec `updateTodo`)
- lors du `onBlur` (quand on sort de l'`input`) il faut mettre √† jour le `editingId` √† `null`
- tu peux finalement modifier les classes de la `div` qui contient la class `input` pour afficher une class quand celui-ci est en train d'√™tre modifier :

```js
clsx("input flex flex-1 items-center gap-2", {
  "input-bordered": editingId === todo.id,
});
```

Si tu n'as pas r√©ussis : aucun soucis. Prends maximum 10 minutes pour faire cette exercice puis regarde la vid√©o solution.

Tu as remarqu√© que notre code √©tait moche ?

Tr√®s tr√®s moche.

C'est car on utilise pas les composnats. On va utiliser les composants pour g√©rer l'√©dition de la todo ainsi que le formulaire et rendre notre code bien plus beau.

## Part 6 : Components

Nos composants sont un peu bord√©lique. On a beaucoup de logique et il serait int√©ressant de refacotr notre components `Todos` en 2 autre components :

- `Todos` : qui va afficher la liste des todos et le formulaire
- `TodoItem` : qui va afficher une todo et qui va prendre en props les m√©thodes `updateTodo` et `removeTodo`
- `TodoForm` : qui va prendre en props la m√©thode `addTodo`

Je te laisse faire ceci afin d'avoir un code parfait !

##¬†Ce qu'on a appris

- A utiliser les states immuables
- A ajouter / modifier / supprimer des √©l√©ments dans une liste
- A cr√©er des custom hooks
- A refactoriser un composant en plusieurs composants
